***************************************
** ASPENModelGen Commandline Options **
***************************************
** Format **
************
ASPENModelGen=modelname=name:mode=number:entryfunction=entryfunc:complement=0|1:functions=foo,bar:postprocessing=number
//If no option is specified, default options (mode = 3, complement = 0, postprocessing = 2) will be used.

*************
** Options **
*************
- mode=number // if number == 0, skip ASPEN model generation
            //              1, analyze the input program and annotate the output C files.
                            2, generate the output ASPEN model only with ASPEN directives in the input files (skipping automatic analysis)
                            3, analyze the input program, annotate the output C files, and generate the output ASPEN model. (default)
                            4, analyze the input program, annotate the output C files, generate the output ASPEN model, and modify output OpenACC program to selectively offload compute region based on ASPEN-generated prediction function (this requires a separate ASPEN tool).

- modelname=name //set the name of ASPEN model generated by OpenARC.

- entryfunction=funcname //set the entry function; OpenARC will generate ASPEN model only for the codes reachable from the entry function.

- functions=funcname1,funcname2,... //set the list of functions to be ignored (not generating ASPEN models for them); if complement is set to 1, functions not in this list will be ignored.

- complement=0|1 //if set to 0, functions in the functions option will be ignored. (default)
                             1, functions not in the functions option will be ignored.

- postprocessing=number 
        //if number == 0, do not perform any postprocessing.
                       1, inline ASPEN kernels called within a ASPEN maps.
                       2, inline ASPEN kernels called within a ASPEN maps + merge consecutive ASPEN maps if allowed (default).
                       

******************************
** ASPEN Modeling Directive **
******************************
**********************************************************
** ASPEN directives to specify a target region to model **
**********************************************************
#pragma aspen enter modelregion [label(model-name)]

#pragma aspen exit modelregion [label(model-name)]

#pragma aspen modelregion [label(model-name)]
//atached to structured block

///////////
//Example//
///////////
#pragma aspen  modelregion label(block_main23)


**************************************************
** ASPEN directives to declare ASPEN param/data **
**************************************************
#pragma aspen declare [clause[[,] clause]...]

where clause is one of the following
param(param-arg-list) 
	where param-arg is one of the following:
	identifier[:init-exp] //ASPENParam
		//contains a list of Aspen parameters, 
		//where each parameter is in the form of identifier[:expression]
		//e.g., param(n:1000, ntimes:0)
data(data-arg-list)	
	where data-arg is one of the following:
	identifier:traits(trait-list)	//ASPENData
		//contains a list of Aspen data, where each data is 
		//in the form of identifier:traits(trait-list)
		//e.g., data(matA:traits(Matrix(n, n, wordSize)),
		//      matB:capacity(n*n*wordSize))

///////////
//Example//
///////////
// To add Aspen parameter that does not exist in the input program,
// the param name should start with "aspen_".
#pragma aspen  declare param(aspen_param_float:4)
#pragma aspen  declare data(a:capacity(4*M*N))


******************************************************
** ASPEN directives to describe ASPEN control flows **
** and modeling properties                          **
******************************************************
#pragma aspen control [clause[[,] clause]...]
//atached to structured block

where clause is one of the following
ignore
		//skips Aspen model generation for the attached statement
execute
		//does not analyze the attached statement; instead generates 
		//Aspen model only with annotated Aspen directives
loop [(itr-size)]
		//contains iteration counts of the attached loop
if (cond-exp-list)
		//contains a list of condition expressions
probability (prob-exp-list)
		//contains a list of the probability expressions
parallelism (para-arg)
		//expresses the amount of independent work 
		//in the attached statement, in the form of
		//expression[:traits(trait-list)]
flops (flops-arg-list)
		//contains a list of Aspen flop resources, 
		//in the form of expression[:traits(trait-list)]
loads (loads-arg-list)
		//contains a list of memory loads, in the form of 
		//expression[:from(ID)][:traits(trait-list)]
stores (stores-arg-list)
		//contains a list of memory stores, in the form of 
		//expression[:to(ID)][:traits(trait-list)]
messages (messages-arg-list)
		//contains a list of internode communications, 
		//in the form of expression [:traits(trait-list)]
intracomm (messages-arg-list)
		//contains a list of intranode transfers, 
		//in the form of expression[:traits(trait-list)]
allocates (memory-arg-list)
		//contains a list of allocated data, in the form of 
		//ID:capacity(expression)[:traits(trait-list)]
resizes (memory-arg-list)
		//contains a list of resized data, in the form of 
		//ID:capacity(expression)[:traits(trait-list)]
frees (memory-arg-list)
		//contains a list of freed data, in the form of 
		//ID:capacity(expression)[:traits(trait-list)]
label (name)
		//contains the label of the attached statement

where para-arg is one of the following:
exp[:traits(trait-list)]	//ASPENResource

where flops-arg is one of the following:
size-exp[:traits(trait-list)]	//ASPENResource

where loads-arg is one of the following:
size-exp[:from(ID)][:traits(trait-list)]	//ASPENResource

where stores-arg is one of the following:
size-exp[:to(ID)][:traits(trait-list)]	//ASPENResource

where message-arg is one of the following:
size-exp[:to(ID)][:traits(trait-list)]	//ASPENResource

where memory-arg is one of the following:
identifier:capacity(exp)[:traits(trait-list)]	//ASPENData

///////////
//Example//
///////////
// A label clause is optional in the Aspen control directive; if not specified, 
// the compiler will automatically add a unique label to each control directive.
// To see more examples, run the example in ${openarc}/test/matmul_aspen and see 
// the output C file in the cetus_output directory.
#pragma aspen control ignore
#pragma aspen  control label(block_MatrixMultiplication_openacc8) loop(M) parallelism(M)
#pragma aspen  control execute label(block_MatrixMultiplication_openacc13) flops((2*P):traits(sp, simd)) loads(((1*aspen_param_float)*P):from(b):traits(stride(1)), ((1*aspen_param_float)*P):from(c))
#pragma aspen  control execute label(block_MatrixMultiplication_openacc14) stores((1*aspen_param_float):to(a):traits(stride(1)))
